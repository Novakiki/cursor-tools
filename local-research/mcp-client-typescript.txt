Querying perplexity using sonar-pro for: MCP client in TypeScript examples: How to implement a MCP client in a TypeScript application? Provide examples, sample code, and architecture guidelines for creating an MCP client to interact with an MCP server using our LLM as a driver. with maxTokens: 8000
To implement an MCP client in a TypeScript application, you can use the MCP TypeScript SDK. Here's an example of how to create an MCP client and interact with an MCP server:

```typescript
import { MCPConnectionManager } from 'mcp-client';

async function main() {
  // Initialize the MCP Connection Manager
  const manager = new MCPConnectionManager();
  await manager.initialize('./mcp-config.json');

  // Get a client for a specific server
  const client = manager.getClient('memory');

  if (client) {
    // List available tools
    const tools = await client.listTools();
    console.log('Available tools:', tools);

    // Use a tool
    const result = await client.useTool('add', { a: 5, b: 3 });
    console.log('Tool result:', result);

    // List available resources
    const resources = await client.listResources();
    console.log('Available resources:', resources);

    // Read a resource
    const resourceContent = await client.readResource('file:///example.txt');
    console.log('Resource content:', resourceContent);
  }

  // Clean up when done
  await manager.cleanup();
}

main().catch(console.error);
```

This example demonstrates how to:

1. Initialize the MCP Connection Manager
2. Connect to a specific MCP server
3. List available tools and resources
4. Use a tool
5. Read a resource
6. Clean up the connection

To set up your MCP client, follow these architecture guidelines:

1. Create a configuration file (e.g., `mcp-config.json`) to specify the MCP servers you want to connect to[4]:

```json
{
  "mcpServers": {
    "memory": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"]
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/allowed/directory"]
    }
  }
}
```

2. Use the `MCPConnectionManager` to manage connections to multiple MCP servers[4].

3. Implement error handling and proper cleanup to ensure robust client behavior.

4. Use TypeScript's type system to ensure type safety when interacting with MCP servers.

5. Consider implementing an abstraction layer to simplify interactions with multiple MCP servers if your application requires it.

Here's an example of a more structured MCP client implementation:

```typescript
import { MCPConnectionManager, MCPClient } from 'mcp-client';

class MCPClientWrapper {
  private manager: MCPConnectionManager;
  private clients: Map<string, MCPClient>;

  constructor() {
    this.manager = new MCPConnectionManager();
    this.clients = new Map();
  }

  async initialize(configPath: string) {
    await this.manager.initialize(configPath);
    for (const serverName of this.manager.getServerNames()) {
      const client = this.manager.getClient(serverName);
      if (client) {
        this.clients.set(serverName, client);
      }
    }
  }

  async useToolOnServer(serverName: string, toolName: string, params: any) {
    const client = this.clients.get(serverName);
    if (!client) {
      throw new Error(`No client found for server: ${serverName}`);
    }
    return await client.useTool(toolName, params);
  }

  async readResourceFromServer(serverName: string, resourceUri: string) {
    const client = this.clients.get(serverName);
    if (!client) {
      throw new Error(`No client found for server: ${serverName}`);
    }
    return await client.readResource(resourceUri);
  }

  async cleanup() {
    await this.manager.cleanup();
  }
}

// Usage
async function main() {
  const mcpClient = new MCPClientWrapper();
  await mcpClient.initialize('./mcp-config.json');

  try {
    const addResult = await mcpClient.useToolOnServer('memory', 'add', { a: 5, b: 3 });
    console.log('Add result:', addResult);

    const fileContent = await mcpClient.readResourceFromServer('filesystem', 'file:///example.txt');
    console.log('File content:', fileContent);
  } finally {
    await mcpClient.cleanup();
  }
}

main().catch(console.error);
```

This implementation provides a higher-level abstraction for interacting with multiple MCP servers, making it easier to manage connections and perform operations across different servers[4][5].

Remember to handle errors appropriately and ensure proper cleanup of resources when your application is done using the MCP clients[4].

By following these guidelines and examples, you can create a robust MCP client in TypeScript to interact with MCP servers, allowing your LLM-driven application to access various tools and resources provided by these servers.